//
//  AsyncAwaitMainActorView.swift
//  Common
//
//  Created by Ricardo Santos on 07/08/2024.
//

import Foundation
import SwiftUI

/**
 # Where should the @MainActor attribute go?

 in this article we’re going to look at some of the actual SIL (Swift Intermediate Language) code
 generated by those mechanisms to examine the relative efficiency and code size of each

 https://medium.com/the-swift-cooperative/async-await-and-mainactor-strategies-cc35b6c58b52
 */

public extension CommonLearnings {
    struct AsyncAwaitMainActorView: View {
        typealias ViewModel = ViewModelV2
        @StateObject var viewModel: ViewModel = .init(loader: AccountLoader())
        public var body: some View {
            Text("Number of accounts = \(viewModel.accounts.count)")
                .background(Color.random.opacity(0.1))
                .task {
                    await viewModel.load()
                }
        }
    }
}

public extension CommonLearnings.AsyncAwaitMainActorView {
    /**
     Basically opting out of Swift concurrency altogether and falling back on `DispatchQueue.main`

     You can do this, but it suffers from all of the drawbacks of the last two solutions. The generated code size it practically identical to that of the Task mechanism above (933 lines) and it will definitely force an update to occur asynchronously.

     With the problems already discussed, like difficulty in testing.
     */
    class ViewModelV7: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                let accounts = try await loader.load()
                DispatchQueue.main.async {
                    self.accounts = accounts
                    self.message = nil
                }
            } catch {
                DispatchQueue.main.async {
                    self.message = "Unable to load"
                }
            }
        }
    }

    /**
     __Task / MainActor__
     This is still 30 lines of source code, but jumps the SIL code up to 935 lines.

     But another, bigger issue is that we’re creating a new task to do the update.
     That task may execute asynchronously, or, depending on load, it may wait for other work to complete

     Run the code, and you’ll see “returning”, and then “updating”.
     */
    class ViewModelV6: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                let accounts = try await loader.load()
                Task { @MainActor in
                    print("updating")
                    self.accounts = accounts
                    message = nil
                }
                print("returning")
            } catch {
                Task { @MainActor in
                    message = "Unable to load"
                }
            }
        }
    }

    /**
     Another solution relies on explicitly reverting back to the main thread yourself using __MainActor.run__

     This seems relatively clean, but doing this generates quite a bit more code behind the
     scenes, taking our source code to 30 lines and the SIL generated code up to 918 lines. A size increase of 15%.
     */
    class ViewModelV5: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                let accounts = try await loader.load()
                await MainActor.run {
                    self.accounts = accounts
                    message = nil
                }
            } catch {
                await MainActor.run {
                    message = "Unable to load"
                }
            }
        }
    }

    /**
     Another solution to the problem often seen is creating update functions annotated with main actor.

     This is often used when people want to perform some sort of additional processing after the await
     function call but before the assignment to the classes instance properties, and they don’t want that processing to occur on the main thread.

     But that approach is problematic for several reasons. First, of course, is that we increased our
     source code size by 20% to 31 lines, and we also increased the generated SIL code to 831 lines.

     The second issue, when we return from await we know that we’re not guaranteed to be on the main thread.
     */
    class ViewModelV4: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                let accounts = try await loader.load()
                await process(accounts) // #3
            } catch {
                await message("Unable to load") // #4
            }
        }

        @MainActor // #1
        func process(_ accounts: [Account]) {
            self.accounts = accounts
        }

        @MainActor // #2
        func message(_ message: String) {
            self.message = message
        }
    }

    /**
     __Annotating the entire class @MainActor.__
     This tells Swift that, in addition to the async behavior shown above, every call to every function
     and every property should also occur on the main actor.

     The size of the generated code is identical to that of the earlier, async-function only version.
     Just 26 lines of source code, and 805 lines of SIL code.

     The problem is that almost everything in the class is marked as @MainActor, and that can cause side-effects
     and knock-on problems elsewhere in our code.
     */
    @MainActor
    class ViewModelV3: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                accounts = try await loader.load()
                message = nil
            } catch {
                message = "Unable to load"
            }
        }

        func process(_ accounts: [Account]) {
            self.accounts = accounts
        }
    }

    /**
     The simplest solution to our problem is simply__ annotating the async function with @MainActor.__

     What may surprise you, however, is that adding the @MainActor annotation to our function increased
     our source code size by one line, but only increased the total generated size to just 805 lines of SIL code.
     A difference of less than one percent.
     */
    class ViewModelV2: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        @MainActor
        func load() async {
            do {
                accounts = try await loader.load()
                message = nil
            } catch {
                message = "Unable to load"
            }
        }
    }

    /**
     The  code works, but when we run this in the simulator we’ll get one of Xcode’s new purple error messages on the lines marked #1 and #2 in the original view model. The message is _“Publishing changes from background threads is not allowed.”_
     */
    class ViewModelV1: ObservableObject {
        @Published var accounts: [Account]
        @Published var message: String?
        let loader: AccountLoader
        init(loader: AccountLoader) {
            self.accounts = []
            self.loader = loader
        }

        func load() async {
            do {
                accounts = try await loader.load() // #1
                message = nil // #2
            } catch {
                message = "Unable to load"
            }
        }

        func process(_ accounts: [Account]) {
            self.accounts = accounts
        }
    }
}

public extension CommonLearnings.AsyncAwaitMainActorView {
    class AccountLoader {
        func load() async throws -> [Account] {
            (1...(Int.random(in: 10...20))).map { _ in .random }
        }
    }

    struct Account: Hashable, Identifiable {
        public let id: String
        let name: String
        static var random: Self {
            Account(id: UUID().uuidString, name: String.random(10))
        }
    }
}

//
// MARK: - Preview
//

#if canImport(SwiftUI) && DEBUG
#Preview {
    CommonLearnings.AsyncAwaitMainActorView()
}
#endif
